\section {Overview}
This chapter provides an overview of Multi-core Integration And Description Specification (MINDS).

\subsection{What is MINDS?}
{\em Multi-Core Integration And Description Specification} describes the structure of MINDS file format, which is the standard used to store programs and libraries on disk in the heterogeneous system architecture. In a heterogeneous system architecture, a process in the operating system has multiple contexts of different instruction set architectures (ISAs) sharing a flat address space. The flat address space makes it possible for several contexts to access objects in shared memory and to keep some objects in private memory. This specification is used to integrate multiple contexts belonging to the same process and to describe the memory organization of all contexts for compilers, assemblers, linkers and loaders.

The MINDS format extends ELF file format. Like ELF, MINDS format provides intermediate and eventual storage of machine code and data. However, in the HSA, HSAIL can not be compiled and linked until on device. A new format must has the ability to store high-level, un-compiled BRIG. For that propose, MINDS format introduce a new portable storage to integrate machine code, data and BRIG. High level language compilers can integrate native CPU code and HSAIL code in the same MINDS file. A MINDS file provides a single view of memory organization to all native CPU code and HSAIL code by a {\em central symbol table } and {\em memory segment table}. By the central symbol table, MINDS allows multiple contexts can refer to the same address of global memory in their kernel functions. By the central segment table, contexts can reserve their private memory segment exclusively. Linkers can avoid multiple contexts from the conflict of address space by manage the central segment table.

The MINDS format also propose a process of address resolution. It proposes a two-stage linking: on-host linking and on-device linking. Since in HSA all addresses of global variables can be known at on-host linking time, on-host linker can resolve all references to global variables among all native CPUs and BRIG code. On-host linker keeps the resolved addresses of all global variables in the central symbol table of MINDS. MINDS is used as a carrier of central symbol table to devices. On-device finalizer extracts BRIG code from MINDS and compiles BRIG into native GPU code. At the last stage, on-device linker incrementally links the finalized GPU code and native CPU code into a single executable program or a shared library. A central segment table is produced at on-device linking stage. The key action of the on-device linker is to resolve the conflict of memory space among all CPU and GPU contexts by the central segment table.

The rest of this specification is organized as follows. Section 2 describes the background of central memory organization: the demand, methods and the proposed solution. Section 3 describes the process of two-stage linking. In this section, we describe the processes of all compilers, linkers and loaders. Section 4 describes MINDS object file layout, sections in ELF. Section 5 describes the detail for on-host linkers. Section 6 describes the detail for on-device linkers. And finally, we describes the detail for on-device loaders in Section 7.
